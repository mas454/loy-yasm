(require "lib/read.rb")
(require "lib/loy.rb")
(def string? (a)
     (a.kind_of? String))
(def number? (o)
     (o.kind_of? Numeric))
(def symbol? (o)
     (o.kind_of? Symbol))
(def pair? (o)
     (o.kind_of? Array))
(def eq? (a b)
     (a.equal? b))

(def null? (a)
     (a.nil?))

(def (open_input_file path)
     (open path "r"))

(def (map fn lis)
     (if (null? lis)
	 nil
	 (cons 
	  (fn.call (car lis))
	  (map fn (cdr lis)))))

(def (append *lis)
     (= app_list nil)
     (lis.map (block (li)
		      (= app_list (cons li app_list))))
     app_list)

(def append2 (xs (ys nil))
    (if (null? xs)
        ys
      (cons (car xs) (append2 (cdr xs) ys))))

(def (reverse lis)
     (= rev (lambda (lis retlis)
	      (if (null? lis)
		  retlis
		(rev.call (cdr lis) (cons (car lis) retlis)))))
     (rev.call lis nil))

(def (newarray *arr)
     arr)

(def (memq sym lis)
     (cond 
      ((null? lis) 
       false)
      ((eq? sym (car lis))
       lis)
      (else
       (memq sym (cdr lis)))))

(def (caar code)
     (car (car code)))

(def (cdar code)
     (cdr (car code)))

(def (cddr code)
     (cdr (cdr code)))

(def (cadr code)
     (car (cdr code)))

(def (caddr code)
     (car (cdr (cdr code))))

(def (cdadr code)
     (cdr (car (cdr code))))

(def (caadr code)
     (car (car (cdr code))))

(def (cadar code)
     (car (cdr (car code))))

(def (a2l array)
     (let ((i 0) (array (array.reverse)) (lis nil))
       (loop 
	(block ()
	       (if (== (array.length) i) break)
	       (= lis (cons (array.get i) lis))
	       (= i (+ i 1))))
       lis))

(def (memq sym lis)
     (cond 
      ((null? lis) 
       false)
      ((eq? sym (car lis))
       lis)
      (else
       (memq sym (cdr lis)))))

(def (assoc key lis)
     (if (null? lis)
	 #f
       (if (eq? key (caar lis))
	   (car lis)
	 (assoc key (cdr lis)))))

(def (transfer ls)
    (if (pair? ls)
        (if (pair? (car ls))
            (if (eq? (caar ls) 'unquote)
                (list 'cons (cadar ls) (transfer (cdr ls)))
              (if (eq? (caar ls) 'unquote-splicing)
                  (list 'append2 (cadar ls) (transfer (cdr ls)))
                (list 'cons (transfer (car ls)) (transfer (cdr ls)))))
          (list 'cons (list 'quote (car ls)) (transfer (cdr ls))))
      (if (null? ls)
	  nil
	(list 'quote ls))))

(macro (quasiquote x)
       (transfer x))

(macro (defclass x *body)
       `(begin
	 (rasm "class ")
	 ,x
	 ,@(a2l body)
	 (rasm "end\n")))
